=== 1.54 ===

- `panic` macro, pointing it at a `pub macro` in `pub mod panic`
- `#[macro_export] macro` (slightly different rules to `macro_rules!` version)
- new `asm` macro
- `pub use bool` to import the primitive type, not a module
- Trait aliases
- Or patterns
  > Hard question between having combinatorial explosion from expanding or patterns early (in HIR generation), or serious changes in destructuring logic.
- Extended use of const generics
  - Now need value inferrence
  - Used in array initialisation
- New language-provided trait impls
- Lots of new `const fn` constructs
- Updated `?` operator
- Use of `!` as a type more (`e.into()` where `E: Into<!>`)
- Right-exclusive range patterns
- Destructuring assignment added (used in `liballoc`)
- `#[cfg]` on function arguments (and struct patterns)
- Custom receivers (Pin) used with inherent impls
- More advanced use of closures locally (broke usage logic)
- atomic pointer ops
- `alloc_error_handler`
- `Box<T>` now has an allocator param
- `cfg(feature="foo")` in Cargo.toml target dependencies
- `$crate` within nested macro (macro defined by a macro)
- `#[rustc_legacy_const_generics]`
- Exporting of macro-defined macros (interpolated expressions)
- `self.foo()` where `Self` implements two traits wtih a `foo` method, one of which is the current impl
- Nested macro expansion edition hygiene
- Variables in constants/statics
- `#[track_caller]` for panics
- `return (1 << shift).abs();` - Literal inference through a method call (likely actually uses traits, implemented using inherents)
- Nested function using traits from parent function
- Extra-nested macro patterns
- `chalk_derive` is pendantic on `struct Binders<T: HasInterner> { ... }`, and doesn't work with `struct Binders<T> where T: HasInterner { ... }`
- `chalk-ir` uses `Enum::<TypeParam>::Variant` instead of `Enum::Variant::<TypeParam>`
- Type recursion in `chalk_solve`, see TypecheckIssues
- Enum patterns in arguments (e.g. `Ok` when `E=!`)
- Implicit formatting arguments (e.g `format!("{foo}")`)
- `mrustc` being better at packing enums than `rustc` (so makes smaller structs than rustc was expecting)
- `[x0 @ xn] | [x0, .., xn] => ` : Multiple bindings for a single value.
- Right-open pattern ranges `foo..`
- Trait-provided associated types
- Type alias that expands its generic parameter twice
  - Defer type aliases (and resolve ufcs) to during main typecheck?
  - OR, allocate ivars really early
- Generic values raised to statics
- U128 literals required
- An annoying-to-debug excessive memset caused by a bad float to u64 cast



=== 1.74 ===
- if-let chains
- `if let` in match guards
- Closure captures
- `FnPtr` trait
- `core::fmt` restructured
- unsized locals
- `const` blocks
- `macro_rules` "operators"
- `Box::new` now recurses with a `#[rustc_box]`-annotated expression.
  - WHY? WHY is Box::new so funky. INTRINSICS EXIST FOR A REASON!
- `Drop for Box` is FINALLY a normal impl!
- `type Foo = impl Trait`
- `libstd` has a reference to `thread_local!` (well, `thread_local_inner!`) that is used before the `mod sys` that defines `thread_local_inner!`)
  - To solve this, need to loop on expand until nothing expands
  - That took ages to code.
- `sizeof(Result<(), NonNull>) == sizeof(NonNull)` (same as `Option`) - mrustc doesn't quite do that
- matching on pointer values `match HANDLE.load(Relaxed) { INVALID => {`
- Excercises `dyn Send` more than existing implementation allowed
- Pre-evaluated pointer casts in `const`s
- `getopts` defined `extern crate alloc as std;`, breaking `format_args!` expansion
- `unreachable!` is a builtin
- `#[derive(Default)]` on enums
- `sigpipe` parameter to `#[lang="start"]`
- Changes to allocator bindings
- Inline assembly used more (including `global_asm!`)
- `offset_of!` macro expands to something interesting - `{builtin # offset_of(...)}`
- `if foo && let Some(bar) = baz` is also valid.
- `#[linkage="extern_weak"]` - Weak linking via nullptr/option
- new `Cargo.toml` keys
- `Cargo.toml` can pull `edition` from the workspace (`cargo`'s `Cargo.toml`)
- Cargo features prefixed with `dep:`
- `proc_macro::is_available`
- `FromStr` impls for `proc_macro::Literal` etc
- `pub use bool;` - Stabilised in 1.43, but wasn't needed until now
- struct literal patterns in pattern-assign with `..`
- More recursive consteval requirements (const functions calling functions with arguments that need consteval?)
  - Can be generalised to needing to do consteval after monomorph in typecheck, maybe as part of EAT
- `Self` in structs/enums/unions (in particular, libtime used in `enum`)
- Traits with ATY specified on parent traits being used in trait objects, vtable gen limitation
- `format_args!` implicit bindings through heavy indenting
- Enum packing - `rustc_parse_format::Piece` two pointers with rustc, three in mrustc
  - mrustc not using null optimisation as well
- `type Foo = impl Trait` is more complex than first seemed, can be set anywhere in module?
  - Need to confirm logic from reference, and to rework implementation
  - See https://rust-lang.github.io/rfcs/2515-type_alias_impl_trait.html
- Attributes on expressions (e.g. on a closure after the `&mut`)
